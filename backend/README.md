# Backend

The workflow depends on `php` and `composer` since it uses [a fork of MySQL Workbench Schema Exporter / Node exporter](https://github.com/molaux/node-exporter) to generate Sequelize models. Thus, the API is driven by [MySQL Workbench](http://www.mysql.com/products/workbench/)

## Install

```bash
$ cd backend
$ yarn ci
```

The project is written as node / ECMAScript module and node is run with `--experimental-specifier-resolution=node`. You need at least node 14. If you use [nvm](https://github.com/nvm-sh/nvm), issue :

```bash
$ nvm use
```

For demonstration purpose, the project uses a SQLLite in memory database : see `config/model.json`. Just adjust this configuration file to persist (or use an existing one) database. For more informations, [see Sequelize documentation](https://sequelize.org/master/manual/getting-started.html#connecting-to-a-database).

## (Re)generate the models (optionnal)

The boilerplate can handle as many Sequelize models as you need. The default repository is named «own» :

```bash
$ yarn generate:models
```

This command lets you regenerate all the models from the [MySQL Workbench file `docs/Model.mwb`](docs/Model.mwb).

Note that this command will ovewrite all models present in `src/models/own`, you should not modify these files. For that purpose, an extensions mechanism handles files in `src/models/own/extensions`. To handle multiple MySQL Workbench autogenerated schemas, you shoud have a look to `config/mysql-workbench-exporter.json` and `package.json`.

## Generate a migration file

Once you regenerated models files, you can (if needed) create a migration file automatically :

```bash
$ yarn generate:migration -r own -n last-changes
```

These migrations will be handled by [Umzug](https://github.com/sequelize/umzug) at the server start.

## Test

The workflow embeds a Jest test suite that handles many aspects of the server : it plays queries and mutations, then checks responses to them. This test suite observes events triggered by subscriptions in response to each request and checks there is no extra data.

The provided test suite introduce the ability to log in and check basic functionality.

 * `tests/gql/*.gql` : The ordered requests to play
 * `tests/subscriptions/*.gql` : The subscriptions to listen to
 * `tests/json/*.json` : The expected results

```bash
$ yarn test
```

## Start

Start against dev env and provide a playground that should be available at [http://localhost:3331/api](http://localhost:3331/api) :

```bash
$ yarn start:dev
```

Start against prod env :
```bash
$ yarn start:prod
```

## API documentation

In order to convert the Sequelize models to a GraphQL schema, the sytem uses [Sequelize GraphQL Schema Builder](https://github.com/molaux/sequelize-graphql-schema-builder). This piece of code transforms a Sequelize schema in a ready to use GraphQL API that exposes queries, mutations and subscriptions for each Sequelize entity you generated. In addition, it exposes data types used by [MUI CRUDF](https://github.com/molaux/mui-crudf) to generate creation and update forms and validate data on client side.

## Controllers

The system instaniates the schema for GraphQL server from `src/schema/index.js`. Here controllers built by [Sequelize GraphQL Schema Builder](https://github.com/molaux/sequelize-graphql-schema-builder) are merged with custom one :

 * `src/schema/authentication` handles all authentication and security policy
 * `src/schema/country` demonstrates how to extend [Sequelize GraphQL Schema Builder](https://github.com/molaux/sequelize-graphql-schema-builder) auto generated API
  * `src/schema/configuration` is a custom controller that exposes a configuration API to client and et a method to share it with other controllers.

